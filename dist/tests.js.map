{"version":3,"sources":["../src/tests.js"],"names":["checks","schema","resolver","resolvers","connectors","definition","operations","definitionList","context","types","Query","resolverQuery","Object","keys","schemaQuery","map","op","name","forEach","indexOf","item","Error","Mutation","resolverMutation","schemaMutation","def","type","operation","connector","prototype","result","filter","obj","length"],"mappings":"AAAA;;;;AAIA;;;;;kBAGwBA,M;;AAFxB;;AAEe,SAASA,MAAT,OAAuC;AAAA,MAApBC,MAAoB,QAApBA,MAAoB;AAAA,MAAZC,QAAY,QAAZA,QAAY;AAAA,MAC5CC,SAD4C,GAClBD,QADkB,CAC5CC,SAD4C;AAAA,MACjCC,UADiC,GAClBF,QADkB,CACjCE,UADiC;AAAA,2BAEGH,OAAOI,UAFV;AAAA,MAE5CC,UAF4C,sBAE5CA,UAF4C;AAAA,MAEhCC,cAFgC,sBAEhCA,cAFgC;AAAA,MAEhBC,OAFgB,sBAEhBA,OAFgB;AAAA,MAEPC,KAFO,sBAEPA,KAFO;;AAIpD;;;;AAGA,MAAIN,UAAUO,KAAd,EAAqB;AACnB,QAAMC,gBAAgBC,OAAOC,IAAP,CAAYV,UAAUO,KAAtB,CAAtB;AACA,QAAMI,cAAcR,WAAWI,KAAX,CAAiBK,GAAjB,CAAqB;AAAA,aAAMC,GAAGC,IAAT;AAAA,KAArB,CAApB;;AAEA;AACAN,kBAAcO,OAAd,CAAsB,gBAAQ;AAC5B,UAAIJ,YAAYK,OAAZ,CAAoBC,IAApB,IAA4B,CAAhC,EAAmC;AACjC,cAAMC,MAASD,IAAT,kDAAN;AACD;AACF,KAJD;;AAMA;AACAN,gBAAYI,OAAZ,CAAoB,gBAAQ;AAC1B,UAAIP,cAAcQ,OAAd,CAAsBC,IAAtB,IAA8B,CAAlC,EAAqC;AACnC,cAAMC,MAASD,IAAT,kDAAN;AACD;AACF,KAJD;AAKD;;AAED;;;AAGA,MAAIjB,UAAUmB,QAAd,EAAwB;AACtB,QAAMC,mBAAmBX,OAAOC,IAAP,CAAYV,UAAUmB,QAAtB,CAAzB;AACA,QAAME,iBAAiBlB,WAAWgB,QAAX,CAAoBP,GAApB,CAAwB;AAAA,aAAMC,GAAGC,IAAT;AAAA,KAAxB,CAAvB;;AAEA;AACAM,qBAAiBL,OAAjB,CAAyB,gBAAQ;AAC/B,UAAIM,eAAeL,OAAf,CAAuBC,IAAvB,IAA+B,CAAnC,EAAsC;AACpC,cAAMC,MACDD,IADC,wDAAN;AAGD;AACF,KAND;;AAQA;AACAI,mBAAeN,OAAf,CAAuB,gBAAQ;AAC7B,UAAIK,iBAAiBJ,OAAjB,CAAyBC,IAAzB,IAAiC,CAArC,EAAwC;AACtC,cAAMC,MACDD,IADC,wDAAN;AAGD;AACF,KAND;AAOD;;AAED;;;AAGA,MAAId,WAAWI,KAAf,EAAsB;AACpBJ,eAAWI,KAAX,CAAiBQ,OAAjB,CAAyB,cAAM;AAC7B,UAAIX,eAAeQ,GAAf,CAAmB;AAAA,eAAOU,IAAIR,IAAX;AAAA,OAAnB,EAAoCE,OAApC,CAA4CH,GAAGU,IAAH,CAAQT,IAApD,IAA4D,CAAhE,EAAmE;AACjE,cAAMI,MACDL,GAAGU,IAAH,CAAQT,IADP,iBACuBD,GAAGC,IAD1B,kCAAN;AAGD;AACF,KAND;AAOD;;AAED;;;AAGA,MAAIX,WAAWgB,QAAf,EAAyB;AACvBhB,eAAWgB,QAAX,CAAoBJ,OAApB,CAA4B,qBAAa;AACvC,UACEX,eAAeQ,GAAf,CAAmB;AAAA,eAAOU,IAAIR,IAAX;AAAA,OAAnB,EAAoCE,OAApC,CAA4CQ,UAAUD,IAAV,CAAeT,IAA3D,IAAmE,CADrE,EAEE;AACA,cAAMI,MACDM,UAAUD,IAAV,CAAeT,IADd,iBAC8BU,UAAUV,IADxC,qCAAN;AAGD;AACF,KARD;AASD;;AAED;;;AAGA,MAAIb,UAAJ,EAAgB;AACdQ,WAAOC,IAAP,CAAYT,UAAZ,EAAwBc,OAAxB,CAAgC,qBAAa;AAC3C,UACE,0BAAcd,WAAWwB,SAAX,EAAsBC,SAApC,EAA+CV,OAA/C,CAAuD,SAAvD,IAAoE,CADtE,EAEE;AACA,cAAME,MACD,uBAAWO,SAAX,CADC,2CAAN;AAGD;AACF,KARD;AASD;;AAED;;;AAGA,MAAIpB,WAAWC,KAAf,EAAsB;AACpBG,WAAOC,IAAP,CAAYL,OAAZ,EAAqBU,OAArB,CAA6B,gBAAQ;AACnC,UAAMY,SAASrB,MAAMsB,MAAN,CAAa;AAAA,eAAOC,IAAIf,IAAJ,KAAaG,IAApB;AAAA,OAAb,CAAf;AACA,UAAIU,OAAOG,MAAP,KAAkB,CAAtB,EAAyB;AACvB,cAAMZ,iBAAeD,IAAf,wCAAN;AACD;AACF,KALD;AAMD;AACF","file":"tests.js","sourcesContent":["/*\n* Checks schema, resolver and mutations for errors\n*/\n\n'use strict';\nimport { getAllMethods, capitalize } from './utils';\n\nexport default function checks ({ schema, resolver }) {\n  const { resolvers, connectors } = resolver;\n  const { operations, definitionList, context, types } = schema.definition;\n\n  /*\n  * check resolver query\n  */\n  if (resolvers.Query) {\n    const resolverQuery = Object.keys(resolvers.Query);\n    const schemaQuery = operations.Query.map(op => op.name);\n\n    // check resolver query operation is in schema query\n    resolverQuery.forEach(item => {\n      if (schemaQuery.indexOf(item) < 0) {\n        throw Error(`${item} is in resolverQuery but not in schemaQuery.`);\n      }\n    });\n\n    // check schema query operation is in resolver query\n    schemaQuery.forEach(item => {\n      if (resolverQuery.indexOf(item) < 0) {\n        throw Error(`${item} is in schemaQuery but not in resolverQuery.`);\n      }\n    });\n  }\n\n  /*\n  * check resolver mutation\n  */\n  if (resolvers.Mutation) {\n    const resolverMutation = Object.keys(resolvers.Mutation);\n    const schemaMutation = operations.Mutation.map(op => op.name);\n\n    // check resolver mutation operation is in schema mutation\n    resolverMutation.forEach(item => {\n      if (schemaMutation.indexOf(item) < 0) {\n        throw Error(\n          `${item} is in resolverMutation but not in schemaMutation.`\n        );\n      }\n    });\n\n    // check schema mutation operation is in resolver mutation\n    schemaMutation.forEach(item => {\n      if (resolverMutation.indexOf(item) < 0) {\n        throw Error(\n          `${item} is in schemaMutation but not in resolverMutation.`\n        );\n      }\n    });\n  }\n\n  /*\n  * check operation query type exists\n  */\n  if (operations.Query) {\n    operations.Query.forEach(op => {\n      if (definitionList.map(def => def.name).indexOf(op.type.name) < 0) {\n        throw Error(\n          `${op.type.name} type on ${op.name} schemaQuery does not exist.`\n        );\n      }\n    });\n  }\n\n  /*\n  * check operation mutation type exists\n  */\n  if (operations.Mutation) {\n    operations.Mutation.forEach(operation => {\n      if (\n        definitionList.map(def => def.name).indexOf(operation.type.name) < 0\n      ) {\n        throw Error(\n          `${operation.type.name} type on ${operation.name} schemaMutation does not exist.`\n        );\n      }\n    });\n  }\n\n  /*\n  * check connectors have a resolve method\n  */\n  if (connectors) {\n    Object.keys(connectors).forEach(connector => {\n      if (\n        getAllMethods(connectors[connector].prototype).indexOf('resolve') < 0\n      ) {\n        throw Error(\n          `${capitalize(connector)} resolver is missing a resolve method`\n        );\n      }\n    });\n  }\n\n  /*\n  * check context types exits\n  */\n  if (context && types) {\n    Object.keys(context).forEach(item => {\n      const result = types.filter(obj => obj.name === item);\n      if (result.length === 0) {\n        throw Error(`Field ${item} type does not exist in schemaType`);\n      }\n    });\n  }\n}\n"]}